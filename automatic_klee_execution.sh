#! /bin/bash

# Directories location to be used
# Include needed libraries to call klee functions and interfacing with c
INCLUDE_DIR=include/

# root directory of each execution. This directory is remove between executions
EXEC_DIR=$3

# src directories include source files
SRC_DIR=$EXEC_DIR/src
# Directory into the main source code file is written
SRC_MAIN_DIR=$SRC_DIR/main
# Directory including files provided by user
SRC_INCLUDE_DIR=$SRC_DIR/include

# lib directories include bytecode files
LIB_DIR=$EXEC_DIR/lib
# Directory into the bytecode for the main module is written
LIB_MAIN_DIR=$LIB_DIR/main
# Directory into a bytecode including all the bytecodes for the files provided by the user is written
LIB_INCLUDE_DIR=$LIB_DIR/include

# output directories include klee output and reports
OUTPUT_DIR=$EXEC_DIR/output
# Directory into the klee output is written
OUTPUT_KLEE_DIR=$OUTPUT_DIR/klee
# Directory into reports, including a summarize of erros and compilation errors, are written
OUTPUT_REPORT_DIR=$OUTPUT_DIR/report

# Converter tool directory
CONVERTER_TOOL_DIR=$EXEC_DIR/tools/converter
# Converter tool sources directory
SRC_EXEC_CONVERTER_TOOL_DIR=$CONVERTER_TOOL_DIR/src
# Converter tool libraries directory
LIB_CONVERTER_TOOL_DIR=$CONVERTER_TOOL_DIR/lib
# Convertert tool bin directory
BIN_CONVERTER_TOOL_DIR=$CONVERTER_TOOL_DIR/bin
# Converter tool source library (common to all execs)
SRC_CONVERTER_TOOL_DIR=tools/converter/src

converter_tool="p_converter"

# LLVM_GCC command options commom to all executions
LLVM_GCC="llvm-gcc -c -emit-llvm -gnatp -I $SRC_INCLUDE_DIR -I $INCLUDE_DIR"

module=$1
main_module="p_klee_main"
external_libs="external_libs.bc"

source_file=$2

#########################################
#### ERROR FUNCTIONS
#########################################

# Display usage message and exit returning code 1
usage () {
  echo "usage $0 <module> <source> <exec_dir>"
  exit 1
}

# Display error message if any of spec or body for input module is not found
# exit by return code 2
file_not_exist () {
  echo "file $1.adb or $1.ads not exists"
  exit 2
}

# Display error message if main file could not be generating and exit with code 3
file_not_generated () {
  echo "Error generating output $main_module.adb file"
  exit 3
}

# Display error when any error occur while compilating any of the included sources
# exit by return code 4
error_compilation_error () {
  echo "Error compilating $1"
  python3 write_compilation_error.py $EXEC_DIR
  exit 4
}

#########################################

# Call a python script to generate the main file to run the symbolic execution
generate_main_module () {
  python3 generate_main_file.py $module $EXEC_DIR
  # If after executing python script main file does not exists print error and exit returning code 3
  if [ ! -f "$SRC_MAIN_DIR/$main_module.adb" ];  then
    file_not_generated
  fi
}

# Generate bytecode of all library files provided and the previously generated main file
# with symbolic instructions
generate_bytecodes () {
  # Generate bytecodes for include files
  for i in `ls $SRC_INCLUDE_DIR/*.adb`; do
    name=`basename "$i" ".adb"`
    # Compilation errors are written in exec/outout/reports/compilation_errors.err
    $LLVM_GCC $i 2> $OUTPUT_REPORT_DIR/compilation_errors.err || error_compilation_error $i
    # Each bytecode (.bc) file is included in a commom bytecode file (external_libs.bc) including all bytecode files
    # Once the bytecode is added to the external_libs remove both .bc and .ali files generated by llvm-gcc
    llvm-ar -r "$LIB_INCLUDE_DIR/$external_libs" "$name.bc" && rm $name.*
  done

  # Generate bytecodes for main file
  # Compilation errors are written in exec/outout/reports/compilation_errors.err
  $LLVM_GCC $SRC_MAIN_DIR/$main_module.adb 2> $OUTPUT_REPORT_DIR/compilation_errors.err || error_compilation_error $main_module.adb
  # Move main module bytecode to exec/lib/main and remove .ali file generated by llvm-gcc
  mv "$main_module.bc" "$LIB_MAIN_DIR/" && rm $main_module.* 
  echo "All bytecode generated"
}

# Run klee command to perform symbolic execution
run_klee_execution () {
  klee --entry-point=_ada_$main_module --external-calls=none --output-dir=$OUTPUT_KLEE_DIR --link-llvm-lib=$LIB_INCLUDE_DIR/$external_libs $LIB_MAIN_DIR/$main_module.bc
}

# Look klee output looking for errors and generate a report with the test cases for each error
read_errors () {
  error_description=""
  if [[ $(ls $OUTPUT_KLEE_DIR/*err 2> /dev/null) ]]; then
    for i in `ls $OUTPUT_KLEE_DIR/*err`; do
      # Each error information is written in a file like test000001.*.err so get the case (test000001) and use it
      # to read the test case (test000001.ktest)
      case=$(ls $i | awk -F. '{print $1}')
      # Briew description about the error (ie Error: divide by zero)
      error_description=$(head -1 $i)
      echo `basename $case` : $error_description > $case.txt
      # Run ktest-tool for the test case to get information about the test case (variable names, values, etc)
      ktest-tool $case.ktest >> $case.txt
      #echo `basename $case_error` : $error_description
    done
  else
    echo "No errors found in symbolic execution"
  fi
}

# Execute converter with the values of all cases generated by klee and keep only the testcases which raise
# exceptions during it execution
read_converter_errors () {
  if [[ -f $OUTPUT_KLEE_DIR/test000001.ktest ]]; then
    num_objects=$(ktest-tool $OUTPUT_KLEE_DIR/test000001.ktest | fgrep "num objects" | awk -F: '{print $2}' | awk '{print $1}')
  fi
  # Loop over all test cases
  for i in `ls $OUTPUT_KLEE_DIR/*.ktest`; do
    case=$OUTPUT_KLEE_DIR/$(basename `ls $i` | awk -F. '{print $1}')
    echo "num objects: $num_objects" > $case.txt
    # Write in report only information about objects
    ktest-tool $i | grep "object " >> $case.txt
    # Get the integer value of all objects to run converter tool
    execution_params=$(ktest-tool $i | fgrep -e " int" | awk -F: '{print $3}' ORS=' ')
    ./$BIN_CONVERTER_TOOL_DIR/$converter_tool $execution_params 2>> $case.err
    # Remove empty lines from error file
    sed -i /^$/d $case.err
    # If test case raise any exception append error file to info file and remove error file
    if [[ -s $case.err ]]; then
      echo "Error: $(cat $case.err)" >> $case.txt && rm $case.err
    # If test case does not have any error remove both files
    else
      rm $case.txt && rm $case.err
    fi
  done
  python3 write_json_report.py $EXEC_DIR
}

# Once symbolic execution ends generate converter to run concretly the program with values in all test cases
write_converter () {
  python3 generate_main_exec_file.py $module $EXEC_DIR
  gnatmake -I$SRC_INCLUDE_DIR -I$SRC_EXEC_CONVERTER_TOOL_DIR -I$SRC_CONVERTER_TOOL_DIR -D $LIB_CONVERTER_TOOL_DIR -o $BIN_CONVERTER_TOOL_DIR/$converter_tool $SRC_EXEC_CONVERTER_TOOL_DIR/"$converter_tool.adb"
}

# Call below functions to generate main file, generate all bytecodes, run klee and give an output 
start () {
  generate_main_module
  generate_bytecodes
  run_klee_execution
  write_converter
  read_converter_errors
  #read_errors
}

# Initialize directory exec structure
init () {
  # If directory exec already exists delete it
  if [ -d $EXEC_DIR ]; then
    rm -rf $EXEC_DIR
  fi
  if [ -d $OUTPUT_KLEE_DIR ]; then
     rm -rf $OUTPUT_KLEE_DIR;
  fi

  ## Create all directories
  mkdir -p $SRC_MAIN_DIR
  mkdir -p $SRC_INCLUDE_DIR
  mkdir -p $LIB_MAIN_DIR
  mkdir -p $LIB_INCLUDE_DIR
  mkdir -p $OUTPUT_REPORT_DIR
  mkdir -p $SRC_EXEC_CONVERTER_TOOL_DIR
  mkdir -p $LIB_CONVERTER_TOOL_DIR
  mkdir -p $BIN_CONVERTER_TOOL_DIR

  # Decompress the uploaded file in exec directory for current execution
  tar xf $source_file --one-top-level=$SRC_INCLUDE_DIR
  # Source could be in several subdirectories, so move all source files to src include dir
  find $SRC_INCLUDE_DIR -name *.ad? -exec mv {} $SRC_INCLUDE_DIR \; 2>/dev/null
  # Remove subdirs with original source code files
  find $SRC_INCLUDE_DIR -mindepth 1 -type d -delete
}

#########################################

init

# Module to be symbolicly executed must be passed as an input param
# If no input params print usage message and exit returning code 1
if [ $# -lt 3 ]; then
  usage
elif [[ -f "$SRC_INCLUDE_DIR/$module.adb" && -f "$SRC_INCLUDE_DIR/$module.ads" ]]; then
  # If module provided and both body and spec exists starts the execution
  start
else
  # If any of the body or the spec of the input module does not exists print error message
  # and exit returning code 2
  file_not_exist "$SRC_INCLUDE_DIR/$module"
fi

exit 0;
